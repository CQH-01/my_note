【[小知识](#小知识)】





#### Makefile 的规则

```
target ... : prerequisites ...
	command
```

- targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；
- prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；
- command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。

> **ps：我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用`Tab`键。**

```shell
test:test.c
	gcc -o test test.c
```



```shell
.PHONY:clean				#伪命令
clean:						#无依赖，clean永远最新，make不会执行，make clean才执行
    rm -rf *.o test
```



#### Makefile通配符

| 通配符 | 使用说明                           |
| ------ | ---------------------------------- |
| *      | 匹配0个或者是任意个字符            |
| ？     | 匹配任意一个字符                   |
| []     | 我们可以指定匹配的字符放在 "[]" 中 |

> **ps : 通配符使用在依赖的规则中时，不能通过引用变量的方式来使用**。

```shell
OBJ=*.c				#非法
test:$(OBJ)
    gcc -o $@ $^
```

要通过引用变量的话，我们要使用一个函数 "wildcard"，这个函数在我们引用变量的时候，会帮我们展开

```shell
OBJ=$(wildcard *.c)
test:$(OBJ)
    gcc -o $@ $^
```



#### Makefile变量

```shell
变量的名称 = 值列表   #值列表，既可以是零项，又可以是一项或者是多项
```

```shell
OBJ = main.o test.o test1.o test2.o
test:$(OBJ)       #变量调用 $(OBJ) 或 ${VALUE_LIST}
      gcc -o test $(OBJ)
```

变量的四种基本赋值方式：

-  简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。
-  递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。
-  条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。
-  追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。



#### Makefile自动化变量

Makefile 中描述规则时，依赖文件和目标文件是变动的，显然在命令中不能出现具体的文件名称，，否则模式规则将失去意义。这时就需要使用自动化变量。

|    | 自动化变量说明                                                    |
| :--------: | --------------------------------------------------- --- |
|     $@     | **表示规则的目标文件名**。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件）， 那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。 |
|     $%     | 当目标文件是一个静态库文件时，代表静态库的一个成员名。       |
|     $<     | **规则的第一个依赖的文件名**。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 |
|     $?     | **所有比目标文件更新的依赖文件列表**，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。 |
|     $^     | **代表的是所有依赖文件列表**，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。 一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况。就是说变量“$^”会去掉重复的依赖文件。 |
|     $+     | 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。 |
|     $*     | 在模式规则和静态模式规则中，代表“茎”。“茎”是**目标模式中“%”所代表的部分**（当文件名中存在目录时， “茎”也包含目录部分）。 |



#### Makefile目标文件搜索（VPATH和vpath）

VPATH 和 vpath 的区别：VPATH 是变量，更具体的说是环境变量，Makefile 中的一种特殊变量，使用时需要指定文件的路径；vpath 是关键字，按照模式搜索，也可以说成是选择搜索。搜索的时候不仅需要加上文件的路径，还需要加上相应限制的条件。

```shell
VPATH := src car
VPATH := src:car
```

多个路径之间要使用空格或者是冒号隔开，表示在多个路径下搜索文件。搜索的顺序为我们书写时的顺序，拿上面的例子来说，我们应该先搜索 src 目录下的文件，再搜索 car 目录下的文件。

```shell
1) vpath PATTERN DIRECTORIES 
2) vpath PATTERN
3) vpath
#( PATTERN：可以理解为要寻找的条件，DIRECTORIES：寻找的路径 )
```

```shell
vpath test.c src     #在 src 路径下搜索文件 test.c
vpath test.c src car    #或 
vpath test.c src : car  #在 src  car 路径下搜索文件 test.c

vpath test.c   #清除符合文件 test.c 的搜索目录。
vpath    #vpath 单独使的意思是清除所有已被设置的文件搜索路径。
```



#### 隐晦规则

隐含规则就是需要我们做出具体的操作，系统自动完成,例如只要 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果 make找到一个 whatever.o，那么 whatever.c，就会是 whatever.o 的依赖文件。并且 cc -cwhatever.c 也会被推导出来。

```shell
test:test.o
    gcc -o test test.o
test:test.c    # cc -c test.c自动推导
```

其实在有些时候隐含规则的使用会出现问题。因为有一个 make 的“隐含规则库”。

```shell
foo.o:foo.p
```

我们都知道 .p 文件是 Pascal 程序的源文件，如果书写规则时不加入命令的话，那么 make 会按照隐含的规则来重建目标文件 foo.o。如果当前目录下恰好存在 foo.c 文件的时候，隐含规则会把 foo.c 当做是 foo.o 的依赖文件进行目标文件的重建。因为编译 .c 文件的隐含规则在编译 .p 文件之前，显然优先级也会越高。

> **ps：隐含条件只能省略中间目标文件重建的命令和规则，但是最终目标的命令和规则不能省略。**



#### Makefile条件判断

| 关键字 | 功能                                              |
| ------ | ------------------------------------------------- |
| ifeq   | 判断参数是否不相等，相等为 true，不相等为 false。 |
| ifneq  | 判断参数是否不相等，不相等为 true，相等为 false。 |
| ifdef  | 判断是否有定义值，有值为 true，没有值为 false。   |
| ifndef | 判断是否有定义值，没有值为 true，有值为 false     |

```shell
ifeq (ARG1, ARG2)
ifeq 'ARG1' 'ARG2'
ifeq "ARG1" "ARG2"
ifeq "ARG1" 'ARG2'
ifeq 'ARG1' "ARG2"

ifeq
else
endif
```



#### 伪目标

```
clean:    rm -rf *.o test
```

规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。

如果当前目录下存在文件名为 clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标`.PHONY`的依赖，如下：

```shell
.PHONY:clean
```

这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。



#### Makefile常用函数

函数调用的格式:

```shell
$(<function> <arguments>)    或者是     ${<function> <arguments>}
```













##### 小知识

- ` \ ` 表示换行

- ` # ` 表示注释
- ` \# ` 表示字符 ` # ` 
- 命令的开始一定要使用`Tab`键
- ` %`  表示取出来文件的文件名（不包含后缀）,与 通配符 ` * ` 有相同的作用
- ` $ ` 取变量值